file std.containers;


@abstract_class
class base_collection<T>:
    private size: std::number;

    @abstract_method
    public function length(self: &auto) -> std::number:
        return this.size;

    @abstract_method
    public function is_empty(self: &auto) -> bool:
        return this.size == 0;

    @abstract_method
    public function clear(mut self: &auto) -> void:
        ...


@abstract_class
class collection<T> inherits std::base_collection<T>
    @abstract_method
    public function contains(self: &auto, item: &T) -> bool:
        ...

    @abstract_method
    public function count(self: &auto, item: &T) -> bool:
        ...


@abstract_class
class sequence<T> inherits std::collection<T>:
    @virtual_method
    public function emplace_head(mut self: &auto, item: T) -> void:
        self.emplace(0, item);

    @virtual_method
    public function emplace_tail(mut self: &auto, item: T) -> void:
        self.emplace(self.length(), item);

    @abstract_method
    public function emplace(mut self: &auto, index: &std::number, item: T) -> void:
        ...

    @virtual_method
    public function pop_front(mut self: &auto) -> T:
        self.pop(0);

    @virtual_method
    public function pop_back(mut self: &auto) -> T:
        self.pop(self.length() - 1);

    @abstract_method
    public function pop(mut self: &auto, index: &std::number) -> T:
        ...

    @virtual_method
    public function at_front(self: &auto) -> &T:
        return self.at(0);

    @virtual_method
    public function at_back(self: &auto) -> &T:
        return self.at(self.length() - 1);

    @abstract_method
    public function at(self: &auto) -> &T:
        ...

    @abstract_method
    public function remove(mut self: &auto, item: &T) -> T:
        self.pop(self.index_of(item));

    @abstract_method
    public function index_of(self: &auto, item: &T) -> std::number:
        ...


@abstract_class
class linked_list<T, N> inherits std::sequence<T>:
    private head: std::optional<N>;
    private tail: std::optional<N>;

    @override_method
    public function is_empty(self: &auto) -> bool:
        return !self.first.has_value();

    @override_method
    public function at_front(self: &auto) -> &T:
        return &self.first.value;

    @override_method
    public function at_back(self: &auto) -> &T:
        return &self.last.value;

    @override_method
    public function count(self: &auto, item: &T) -> std::number:
        ...


class single_linked_list_node<T>:
    friend single_linked_list<T>;

    protected constructor(value: T, next: std::optional<single_linked_list_node<T>> = std::none()):
        this.value = value;
        this.next = next;

    protected value: T;
    protected next: std::optional<single_linked_list_node<T>>;


class single_linked_list<T> inherits std::linked_list<T, single_linked_list_node<T>>:
    @override_method
    public function emplace_head(mut self: &auto, item: T) -> void:
        self.head = single_linked_list_node(item, self.head);
        self.size += 1;

    @override_method
    public function emplace_tail(mut self: &auto, item: T) -> void:
        self.tail.next = single_linked_list_node(item);
        self.size += 1;

    @override_method
    public function emplace(mut self: &auto, index: &std::number, item: T) -> void:
        let mut node = self.head;
        for i <- [0..index]:
            node = node.next;
        node.next = single_linked_list_node(item, node.next);

    @override_method
    public function pop_front(mut self: &auto) -> T:
        let node = self.head;
        self.head = self.head.next;
        self.size -= 1;
        return node.value;

    @override_method
    public function pop_back(mut self: &auto) -> T:
        let mut node = self.head;
        while node.next.has_value():
            node = node.next;
        self.tail = node;
        self.size -= 1;
        return node.value;

    @override_method
    public function pop(mut self: &auto, index: &std::number) -> T:
        let mut node = self.head;
        for i <- [0..index]:
            node = node.next;
        self.size -= 1;
        return node.value;
        
    @override_method
    public function at_front(self: &auto) -> &T:
        return &self.head.value;
        
    @override_method
    public function at_back(self: &auto) -> &T:
        return &self.tail.value;
        
    @override_method
    public function at(self: &auto, index: &std::number) -> &T:
        let mut node = self.head;
        for i <- [0..index]:
            node = node.next;
        return &node.value;
        
    @override_method
    public function remove(mut self: &auto, item: &T) -> T:
        let mut node = self.head;
        while node.next.has_value() && node.next.value() != item
            node = node.next;
        node.next = node.next.next;
        self.size -= 1;
        return node.value;
        
    @override_method
    public function index_of(self: &auto, item: &T) -> std::number:
        let mut node = self.head;
        let mut index = 0;
        while node.next.has_value() && node.next.value() != item:
            node = node.next;
            index += 1;
        return index;
