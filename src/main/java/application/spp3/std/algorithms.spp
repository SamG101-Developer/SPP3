module std.algorithms;


import:
    std.constraints;


# let m = std::vector(0, 1, 2, 3, 4, 5);
# let n = m | std::filter(std::is_prime) | std::enumerate();
# let n = std::enumerate(std::filter(std::is_prime, m));

# std::filter(std::is_prime, m) === m |> std::filter(std::is_prime)
# std::filter(std::is_prime) -> return partial function of the constructor std::filter
# m |> std::filter(std::is_prime, _) |> std::map((x) -> x * 2, _) -> same as std::filter(std::is_prime)(m)
# |> operator just calls the partial function with self as the only argument


@static_class
class rng:

    @static_method
    public generator chunk<I, J=I::value_type>(chunk_length: &std::number, iterable: &I) -> mut std::generator<J> where
            I: std::constraints::iterable, I::value_type: std::constraints::iterable,
            J: std::constraints::iterable:

        for i <- [0..iterable.length(), chunk_length]):
            yield iterable[index:index + chunk_length]


    @static_method
    public generator filter<F, I>(function: F, iterable: &I) -> mut std::generator<I::value_type> where
            I: std::constraints::iterable,
            F: std::constraints::callable_accepts<I::value_type>:

        for element <- iterable:
            function(&element) ? yield &element;


    @static_method
    public generator transform<F, I>(function: F, iterable: &I<T>) -> std::generator<F::return_type> where
            I: std::constraints::iterable,
            F: std::constraints::callable_accepts<I::value_type>:

        for element <- iterable:
            yield self.f(&element);
